# 2025-2 객체지향프로그래밍2 스터디 3주차 - 클래스와 생성자

## 클래스 기초 복습

### 1. 기본 개념
- **클래스(Class)**: 사용자 정의 타입(Type)을 정의하는 설계도.
- **객체(Object)**: 클래스로부터 생성된 인스턴스(Instance).
- **구성 요소**: 데이터 멤버(변수)와 멤버 함수(메서드)로 구성됨.

### 2. 주요 문법 요소
1. **멤버 함수 정의**
    * 클래스 **내부**에 직접 함수 본문을 작성 가능함.
    * 클래스 **외부**에 정의할 경우, 내부에는 함수 원형(프로토타입)만 선언함.

2. **const 멤버 함수**
    * 함수 내에서 클래스의 데이터 멤버 값을 변경할 수 없음.
    * `const`로 선언된 객체는 **`const` 멤버 함수만 호출 가능함.**

3. **접근 제한자 (Access Specifiers)**
    * `private`: 클래스 내부 멤버 함수만 접근 가능.
    * `public`: 외부에서 자유롭게 접근 가능.
    * **Setter/Getter**: `private` 멤버에 접근하고 값을 설정/가져오기 위해 사용하는 `public` 함수.

4. **객체 사용**
    * 접근 연산자 `.`를 이용해 멤버 함수나 변수에 접근함.

### 3. 헤더 중복 포함 방지
- **문제 상황**: 하나의 파일에서 여러 헤더 파일을 include할 때, 같은 헤더가 중복으로 포함되어 **재정의 오류**가 발생할 수 있음.
- **해결 방안**
    * `#ifndef` ~ `#define` ~ `#endif`를 사용하여 특정 매크로가 정의되지 않았을 때만 코드를 포함시킴.
    * `#pragma once`: 컴파일러에게 해당 헤더 파일을 한 번만 포함하도록 지시함.

## 생성자 (Constructor)

### 1. 생성자란?
* 객체가 **생성될 때 자동으로 호출**되는 특별한 멤버 함수.
* 주요 역할은 객체의 **데이터 멤버를 초기화**하는 것.
* 클래스 이름과 동일하며, **리턴 타입이 없음.**
* 하나의 클래스에 여러 개의 생성자를 오버로딩(Overloading)하여 정의할 수 있음.

### 2. 생성자 종류
1. **기본 생성자 (Default Constructor)**
    * 매개변수가 없는 생성자.
    * 사용자가 어떤 생성자도 정의하지 않으면 컴파일러가 자동으로 생성함.

2. **매개변수 생성자 (Parameter Constructor)**
    * 매개변수를 받아 멤버 변수를 원하는 값으로 초기화함.

3. **변환 생성자 (Conversion Constructor)**
    * **단일 매개변수**만 가지는 생성자.
    * 다른 타입의 값을 해당 클래스 타입으로 **암시적으로 변환**할 때 호출됨.
    * **`explicit` 키워드**
    > `explicit` 키워드를 생성자 앞에 붙이면 `=`을 사용한 복사 초기화 방식의 **암시적 형변환을 금지**함. 코드의 가독성과 예측 가능성을 높이기 위해 사용.

## 멤버 초기화 리스트 (Member Initializer List)

### 1. 개념
* 생성자 헤더와 본문 `{}` 사이에 `:`을 사용하여 멤버 변수를 초기화하는 문법.
* 생성자 본문에서 대입하는 것보다 효율적임. (기본 생성 후 대입하는 2단계를 초기화 1단계로 줄임)

### 2. 사용 규칙 및 장점
- **초기화 순서**
    * 멤버 초기화 리스트에 나열된 순서가 아닌, **클래스에 멤버 변수가 선언된 순서대로 초기화가 진행됨.** 따라서 선언 순서와 초기화 순서를 일치시키는 습관이 필요함.

- **필수로 사용하는 경우**
* `const` 멤버 변수 초기화.

## (!중요!) 대입 연산자 (operator=)

### 1. 개념
* 이미 생성된 객체에 다른 객체의 값을 **대입(복사)**할 때 사용되는 연산자 오버로딩.
* `객체1 = 객체2`와 같은 구문에서 호출됨.

    > **생성자가 아님!** 생성은 최초 1회 일어나며, 대입은 이미 존재하는 객체에 값을 덮어쓰는 것.

### 2. 일반적인 형태와 이유
* `ClassName& operator=(const ClassName& other)`
* **리턴 타입이 `ClassName&`인 이유**
* `a = b = c`와 같은 **연속적인 대입**을 가능하게 하기 위함.
* `b = c` 연산 후 `b` 자신의 참조를 리턴하여 `a = b` 연산이 이어짐.
* **매개변수가 `const ClassName&`인 이유**
* **참조(&)**로 받아 불필요한 객체 복사 비용을 줄임.
* **const**로 받아 원본 객체(`other`)의 값이 변경되지 않음을 보장함.
