**Week4 내용정리

**복사생성자란?
특정 class의 객체가 다른 객체로 복사될 때 호출되는 생성자(자동으로 생성됨)
복사생성자는 "새로운 객체"를 생성 시 기존 객체의 데이터를 복사하는 역할을 한다.
자원을 관리할 시 복사 생성자를 통해 깊은 복사를 구현하여 메모리 누수를 방지할 수 있다.

**깊은 복사(Deep Copy) VS 얇은 복사(Shallow Copy)
깊은 복사
정의: 객체의 모든 필드를 복사하며 "포인터가 가리키는 데이터" 또한 복사한다.
메모리 공유: 원본 객체와 복사된 객체가 서로 "다른" 메모리 주소를 가짐.
안정성: 원본 객체와 다른 메모리 주소를 가져 서로 독립적으로 메모리를 관리하므로 안전함.
복사 생성자: 새로운 메모리를 할당한 후 값을 복사한다.
ex) data = new int(*(other.data));

얇은 복사
정의: 객체의 모든 필드를 복사하나 "포인터는 주소만 복사"한다.
메모리 공유: 원본 객체와 복사된 객체가 서로 "같은" 메모리 주소를 공유한다.
안정성: 같은 메모리 주소를 공유하므로 메모리 해제 시 문제가 발생할 가능성이 있음.
복사 생성자: 포인터의 주소만 복사한다.
ex) data = other.data;

**friend
friend는 class의 멤버가 아닌 함수 또는 다른 class에 있는 멤버에게 멤버 수준의 액세스 권한을 부여하는 것
즉 어떤 class의 private / protected 멤버에 접근할 수 있게 되는 역할을 부여함.
friend는 class내부에서 선언해야하며, 만약 함수 내부에서 프로토타입으로 적을 경우 외부에는 friend를 안적어도 됨.
friend는 자신을 class의 friend로 선언할 수 없다.
A class가 B class를 friend로 선언하였다 할지라도 B class가 A class의 friend가 되지는 않음.(이 얼마나 냉정한가.)

**friend의 사용 및 장단점
friend는 두 개의 class가 매우 밀접하게 연관되어 있을 때 주로 사용한다.
한 class가 다른 class의 내부를 접근해야 할 필요가 있을 때 사용하며 복잡한 내부 상태를 조작하거나 효율적인 작업을 위해 서로 내부 정보에 접근할 필요가 있을 때 유용하다.

friend의 장단점은 무엇일까?
특정 class가 다른 class의 내부 데이터에 직접 접근하기 때문에 객체 간의 상호 작용이 용이하다.
또한 복잡한 접근자를 작성할 필요가 없어 코드가 훨씬 간결해진다.
단 friend를 아무렇게나 사용할 경우 class의 캡슐화가 깨질 위험이 있다.
또한 friend가 많아질수록 코드가 더욱 복잡해지므로 꼼꼼히 관리하는 것이 중요하다.
